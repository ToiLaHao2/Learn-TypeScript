1. What is TypeScript?
    TypeScript is a syntactic superset of JavaScript which adds static typing.

    This basically means that TypeScript adds syntax on top of JavaScript, allowing developers to add types.

    => TypeScript allows developers to add TYPES.

2. Why should we use TypeScript?
    TypeScript uses compile time type checking. Which means it checks if the specified types match before running the code, not while running the code.
    This helps in catching errors early in the development process, reducing bugs and improving code quality.

3. How do we use TypeScript?
    A common way to use TypeScript is to use the official TypeScript compiler, which transpiles TypeScript code into JavaScript.

    Some popular code editors, such as Visual Studio Code, have built-in TypeScript support and can show errors as you write code!

    Extension of VSC that developers can use to program with TypeScript: ESLint, Prettier or Prettier ESLint, Code Spell Checker, Path Intellisense,
    Auto Rename Tag, Better comments, TypeScript importer, TypeScript toolbox, DotENV, Quokka.js
        
4. TypeScript compiler
    TypeScript being converted into JavaScript means it runs anywhere that JavaScript runs!

    Steps to install the compiler
    1. Install NodeJs
    2. Install TypeScript
        2.1. Open terminal
       
        2.2. npm install -g typescript (Install TypeScript Globally (Recommended for learning and general use))
        
        2.3. Install TypeScript for the project
            2.3.1. Create project folder:
                
                mkdir my-typescript-project
                cd my-typescript-project

            2.3.2. Create project
                
                npm init -y

            2.3.3. Install TypeScript as a developer dependency (devDependencies):
                
                npm install --save-dev typescript

    3. Check TypeScript version
        
        tsc -v
        npx tsc

5. Configuring the compiler

By default the TypeScript compiler will print a help message when run in an empty project.

The compiler can be configured using a tsconfig.json file.

You can have TypeScript create tsconfig.json with the recommended settings with:

    1. Open terminal and move to your project:
        
        cd your-project
    
    2. Type :

        npx tsc --init

6. TypeScript Simple Types

    There are three main primitives in JavaScript and TypeScript.

        boolean - true or false values
        number - whole numbers and floating point values
        string - text values like "TypeScript Rocks"

    There are also 2 less common primitives used in later versions of Javascript and TypeScript.

        bigint - whole numbers and floating point values, but allows larger negative and positive numbers than the number type.
        symbol are used to create a globally unique identifier.

7. Type Assignment

    When creating a variable, there are two main ways TypeScript assigns a type:

        - Explicit: writing out the type: (Recommended)
            
            Ex: let firstName: string = "Dylan";

                => Explicit type assignment are easier to read and more intentional.
        
        - Implicit: TypeScript will "guess" the type, based on the assigned value:

            Ex: let firstName = "Dylan";

                => Having TypeScript "guess" the type of a value is called infer.
                => Implicit assignment forces TypeScript to infer the value.
                   Implicit type assignment are shorter, faster to type, and often used when developing and testing.

8. Error In Type Assignment

    TypeScript will throw an error if data types do not match.

    Ex : 

        let firstName: string = "Dylan"; // type string
        firstName = 33; // attempts to re-assign the value to a different type

    Implicit type assignment would have made firstName less noticeable as a string, but both will throw an error

    Ex :

        let firstName = "Dylan"; // inferred to type string
        firstName = 33; // attempts to re-assign the value to a different type

    => JavaScript will not throw an error for mismatched types.

9. Unable to Infer

    TypeScript may not always properly infer what the type of a variable may be. In such cases, it will set the type to any which disables type checking.

    Ex :

        // Implicit any as JSON.parse doesn't know what type of data it returns so it can be "any" thing...
        const json = JSON.parse("55");
        // Most expect json to be an object, but it can be a string or a number like this example
        console.log(typeof json); (number)

    This behavior can be disabled by enabling noImplicitAny as an option in a TypeScript's project tsconfig.json. That is a JSON config file for customizing how some of TypeScript behaves.

    ! Note: you may see primitive types capitalized like Boolean.

    boolean !== Boolean
    For this tutorial just know to use the lower-cased values, the upper-case ones are for very specific circumstances.

10. TypeScript Special Types
    
    TypeScript has special types that may not refer to any specific type of data.

        - Type: any

            -> any is a type that disables type checking and effectively allows all types to be used.

                The example below does not use any and will throw an error:

                Ex: 
                    // without any
                    let u = true;
                    u = "string"; // Error: Type 'string' is not assignable to type 'boolean'.
                    Math.round(u); // Error: Argument of type 'boolean' is not assignable to parameter of type 'number'.

                    // with any
                    let v: any = true;
                    v = "string"; // no error as it can be "any" type
                    Math.round(v); // no error as it can be "any" type

        - Type: unknown

            -> unknown is a similar, but safer alternative to any.

                TypeScript will PREVENT unknown types from being used, as shown in the below example:

                Ex:

                    let w: unknown = 1;
                    w = "string"; // no error
                    w = {
                    runANonExistentMethod: () => {
                        console.log("I think therefore I am");
                    }
                    } as { runANonExistentMethod: () => void}
                    // How can we avoid the error for the code commented out below when we don't know the type?
                    // w.runANonExistentMethod(); // Error: Object is of type 'unknown'.
                    if(typeof w === 'object' && w !== null) {
                    (w as { runANonExistentMethod: Function }).runANonExistentMethod();
                    }
                    // Although we have to cast multiple times we can do a check in the if to secure our type and have a safer casting
                
            Compare the example above to the previous example, with any.
                ->  unknown is best used when you don't know the type of data being typed. To add a type later, you'll need to cast it.

                    Casting is when we use the "as" keyword to say property or variable is of the casted type.

        - Type: never

            -> never effectively throws an error whenever it is defined.

                Ex:

                    let x: never = true; // Error: Type 'boolean' is not assignable to type 'never'.
            
            never is rarely used, especially by itself, its primary use is in advanced generics.

        - Type: undefined & null

            -> undefined and null are types that refer to the JavaScript primitives undefined and null respectively.

                Ex:

                    let y: undefined = undefined;
                    let z: null = null;

            These types don't have much use unless strictNullChecks is enabled in the tsconfig.json file.

11. TypeScript Arrays

    TypeScript has a specific syntax for typing arrays.

        Ex: 

            const names: string[] = [];
            names.push("Dylan"); // no error
            // names.push(3); // Error: Argument of type 'number' is not assignable to parameter of type 'string'.

    - Readonly: The readonly keyword can prevent arrays from being changed.

        Ex: 
        
            const names: readonly string[] = ["Dylan"];
            names.push("Jack"); // Error: Property 'push' does not exist on type 'readonly string[]'.
            // try removing the readonly modifier and see if it works?

    - Type Inference: TypeScript can infer the type of an array if it has values.

        Ex: 
        
            const numbers = [1, 2, 3]; // inferred to type number[]
            numbers.push(4); // no error
            // comment line below out to see the successful assignment
            numbers.push("2"); // Error: Argument of type 'string' is not assignable to parameter of type 'number'.
            let head: number = numbers[0]; // no error

12. TypeScript Tuples

    - Typed Arrays:

        A tuple is a typed array with a pre-defined length and types for each index.

        Tuples are great because they allow each element in the array to be a known type of value.

        To define a tuple, specify the type of each element in the array:

            Ex:

                // define our tuple
                let ourTuple: [number, boolean, string];

                // initialize correctly
                ourTuple = [5, false, 'Coding God was here'];

        As you can see we have a number, boolean and a string. But what happens if we try to set them in the wrong order:

            Ex: 
            
                // define our tuple
                let ourTuple: [number, boolean, string];

                // initialized incorrectly which throws an error
                ourTuple = [false, 'Coding God was mistaken', 5];
            
        Even though we have a boolean, string, and number the order matters in our tuple and will throw an error.

    - Readonly Tuple:

        A good practice is to make your tuple readonly.

        Tuples only have strongly defined types for the initial values:

            Ex: 

                // define our tuple
                let ourTuple: [number, boolean, string];
                // initialize correctly
                ourTuple = [5, false, 'Coding God was here'];
                // We have no type safety in our tuple for indexes 3+
                ourTuple.push('Something new and wrong');
                console.log(ourTuple);
            
        You see the new valueTuples only have strongly defined types for the initial values:

            Ex: 

                // define our readonly tuple
                const ourReadonlyTuple: readonly [number, boolean, string] = [5, true, 'The Real Coding God'];
                // throws error as it is readonly.
                ourReadonlyTuple.push('Coding God took a day off');

        To learn more about access modifiers like readonly go to our section on them here: TypeScript Classes.

        ! If you have ever used React before you have worked with tuples more than likely.

            useState returns a tuple of the value and a setter function.

            const [firstName, setFirstName] = useState('Dylan') is a common example.

            Because of the structure we know our first value in our list will be a certain value type in this case a string and the second value a function.

    - Named Tuples:

        Named tuples allow us to provide context for our values at each index.

            Ex: 

                const graph: [x: number, y: number] = [55.2, 41.3];

        -> Named tuples provide more context for what our index values represent.

    - Destructuring Tuples:

        Since tuples are arrays we can also destructure them.

            Ex:

                const graph: [number, number] = [55.2, 41.3];
                const [x, y] = graph;

13. TypeScript Object Types

    TypeScript has a specific syntax for typing objects.

        Ex:

            const car: { type: string, model: string, year: number } = {
                type: "Toyota",
                model: "Corolla",
                year: 2009
            };
    
    -> Object types like this can also be written separately, and even be reused, look at interfaces for more details.

    - Type Inference:

        TypeScript can infer the types of properties based on their values.

        Ex:

            const car = {
                type: "Toyota",
            };
            car.type = "Ford"; // no error
            car.type = 2; // Error: Type 'number' is not assignable to type 'string'.
    
    - Optional Properties:

        Optional properties are properties that don't have to be defined in the object definition.

        Ex without an optional property:

            const car: { type: string, mileage: number } = { // Error: Property 'mileage' is missing in type '{ type: string; }' but required in type '
            { type: string; mileage: number; }'.
                type: "Toyota",
            };
            car.mileage = 2000;
        
        Ex with an optional property